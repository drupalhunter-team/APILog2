// Константы //////////////////////////////////////////////////////////////////////////////////////


// Классификация значений
#define VL_TYPE			0x0000FFFF // Номер типа (0 - 65535)
#define VL_PTRS			0x00FF0000 // Количество указателей (*)
#define VL_SIGNED		0x10000000 // Знаковое число
#define VL_FLOAT		0x20000000 // Описание типа
#define VL_TYPEDEF		0x40000000 // Описание типа, иначе - значение
#define VL_STRUCDEF		0x80000000 // Описание структуры
#define VL_INITED		0x01000000 // Инициализировано
#define VL_VAR			0x02000000 // Переменная
#define VL_VALISVAR		0x02000000 // Переменная
#define VL_NAME			0x04000000 // Имя
#define VL_VALISNAME	0x04000000 // Имя

#define VL_pointer	0x00010000


#define VL_void		0 // Тип void
#define VL_char		1 | VL_SIGNED
#define VL_short    2 | VL_SIGNED
#define VL_int	    3 | VL_SIGNED
#define VL_float	4 | VL_FLOAT
#define VL_double	5 | VL_FLOAT	
#define VL_pchar	VL_char | VL_pointer
#define VL_pvoid	VL_void | VL_pointer



// Классификация операций (OPERATOR.Flags)
#define OP_FORWARD	0x00000001 // При равном приоритете, раньше выполняется левая операция

#define OP_PREFIX	0x00000002 // Операция может быть префиксной
#define OP_POSTFIX	0x00000004 // Операция может быть постфиксной
#define OP_BINARY	0x00000008 // Операция может быть бинарной

#define OP_BRCLOSE	0x00000010 // Открывающая скобка
#define OP_BROPEN	0x00000020 // Закрывающая скобка
#define OP_BRID		0x000000C0 // Тип скобок
#define OP_BRACKET	(OP_CLOSE | OP_OPEN)
#define OP_BRTRIVAR	0x00000100 // Трёхоперандные скобки ( ? : )


#define OP_INITA	0x00001000 // Первый параметр должен быть инициализирован
#define OP_LEFTA	0x00002000 // Первый параметр должен быть леводопустимым
#define OP_NAMEA	0x00004000 // Первый параметр должен иметь имя

#define OP_INITB	0x00010000 // Второй параметр должен быть инициализирован
#define OP_LEFTB	0x00020000 // Второй параметр должен быть леводопустимым
#define OP_NAMEB	0x00040000 // Второй параметр должен иметь имя

#define OP_INIT0	0x00100000 // Нулевой параметр должен быть инициализирован
//define OP_LEFT0	0x00200000 // От нулевого параметра нельзя требовать леводопустимости!
#define OP_NAME0	0x00400000 // Нулевой параметр должен иметь имя

#define OP_INITR	0x00200000 // Результат инициализирован.
#define OP_LEFTR	0x00800000 // Результат леводопустим.


#define OP_STDBIN	(OP_FORWARD | OP_INITA | OP_INITB | OP_BINARY | OP_INITR)

// Максимальный приоритет операции
#define	MAX_PRIOR	32


// Состояние переменной записи (STACKREC.Flags)
#define SR_VALUE	0x10000000 // Инициализировано
#define SR_REFER	0x20000000 // Есть ссылка на переменную
#define SR_PRESENT  (SR_REFER | SR_VALUE)
#define SR_SHIFTA	24
#define SR_SHIFTB	22


//#define SR_PRIORITY 0x0FFFFFFF // Приоритет

// Макроопределения ///////////////////////////////////////////////////////////////////////////////

#define IsLetter(c) (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')) || ((c >= '0') && (c <= '9')) || (c == '_'))
#define IsDigit(c) ((c >= '0') && (c <= '9'))
#define IsSign(c) (!IsLetter(c) && (c > ' '))

// Типы ///////////////////////////////////////////////////////////////////////////////////////////

class TSyntaxParser;										// Класс парсера
typedef struct _OPERATOR OPERATOR;
typedef void * TReference;									// Ссылка
typedef bool (* TFOperator) (OPERATOR * Operator, void * Var1, void * Var2, void * Result);	// Указатель на функцию выполняющую оператор

// Структуры //////////////////////////////////////////////////////////////////////////////////////

// Описание значения
typedef struct _VALUE {
	void * Value;	// Само значение или указатель на него. Если Type & VL_VALISVAR, то указывает на переменную
	int Type;		// Тип значения (Флаги VL_)
} VALUE;

typedef char * (* TFValReader) (char * Text, VALUE * Result); // Указатель на функцию чтения значения, возвращает 
															  // указатель на следующий после значения символ

// Описание оператора. Список операторов должен быть отсортирован в порядке уменьшения длины мнемоники оператора!
typedef struct _OPERATOR {
	char		Sign[4];	// Мнемоника оператора 
	int			Priority;	// Приоритет
	int			Flags;		// Флаги (OP_...)
	TFOperator	Function;
} OPERATOR;

// Описание переменной
typedef struct _VARIABLE {
	char *		Name;		// Имя переменной
	int			Flags;		// OP_. Е
	VALUE		Value;		// Значение переменной
} VARIABLE;

typedef bool (* TFVariable) (VARIABLE * Var1, void * Var2, void * Result);	// Указатель на функцию переменной


/*VARIABLE BaseTypes[] =
{
	{"int", 0, 0, VL_int | VL_TYPEDEF}


};*/

// Описание стековой записи
typedef struct _STACKREC {
	VALUE Value;			// Значение. Если требуется, указатель на переменную хранить в Value.Value (VL_VALISVAR)
	OPERATOR * Operator;	// Оператор
	int Priority;			// Приоритет
} STACKREC;

// Классы /////////////////////////////////////////////////////////////////////////////////////////

class TSyntaxParser
{
private:
	TFValReader	ReadValue;	// Функция чтения значения
	STACKREC Rec;			// Временная ячейка
	OPERATOR * Operators;	// Массив операторов
	OPERATOR * NullOperator;// Оператор с пустой мнемоникой
	int OpCount;			// Количество операторов
	VARIABLE Variables[128];// Массив переменных
	int VarCount;			// Количество переменных
	STACKREC StackBase[128];// Массив стека переупорядочения
	STACKREC * Stack;		// Вершина стека переупорядочения
	bool AddToStack(OPERATOR * Operator);
	OPERATOR * GetOperator(char * * Name, int Flags);
public:
	TSyntaxParser(OPERATOR * Operators, int Count, TFValReader ValReader);
	VARIABLE * FindVariable(char * * Name);
	VARIABLE * AddVariable(char * * Name, VALUE * Value = 0); // Добавить переменную
	VALUE * Parse(char * s); // Разобрать строку, получить результат
	int GetOperatorIndex(OPERATOR * Operator);
};

//Вспомогательные функции

char * CompareLetters(char * a, char * b);
char * ReadIntegerValue(char * Text, VALUE * Result);


/**********************************************************************************************************************\

	Принцип работы парсера:

  /-----------\        /------------------\         /------------\       /------------\
  | Строковое | >>>>>> | Стек  отложенных | >>>>>>> | Выполнение |  /--->| Список     |
  | выражение |        |    операторов    |         \------------/  |    | переменных |
  \-----------/        \------------------/                         |    \------------/
                       |Операторы|Значения|                         |
                       |         |        |-----VL_VALISVAR---------/
  /------------\       |         |        |
  | Список     |       |         |        |
  | операторов |<------|         |        |
  |            |       |         |        |
  \------------/       |         |        |
                       |         |        |
				       \------------------/		



	Класс TSyntaxParser

  Получает список операторов, с указанием:
	1. Значки.
	2. Указатели на функции операторов.
	3  Приоритеты, синтаксис и т.п.
	4. Требуемость инициализирования входных значений и наличия переменных.

	Тип TValue

  Является указателем на значение. В простейших случаях может использоваться как значение. Ответственность за
  выделение/освобождение памяти под значение берут на себя функции операторов.

typedef struct _VALUE {
	void * Value;	// Само значение или указатель на него. Если Type & VL_VALISVAR, то указывает на переменную
	int Type;		// Тип значения (Флаги VL_)
} VALUE;

  Базовые признаки значения:
  1. Переменная: VL_VALISVAR.
  2. Значение инициализированно: VL_INITED.
  3. [Неизвестное] имя: VL_VALISNAME.
  4. Леводопустимость VL_LEFT. Есть всегда при VL_VALISVAR

	Аксиомы С++:
  * У любой переменной есть постоянный тип.
  * У любого значения есть тип.
  * У любого инициализированного значения есть участок памяти.
  * У любой переменной есть постоянный указатель на её значение.
  * У любой переменной есть постоянное имя.
  * У любой переменной есть значение, но не обязательно инициализированное.
  * Значение может существовать вне переменной и не иметь имени.
  * Имя значения начинается с цифры или кавычки, и однозначно определяет его тип.
  * Имена типов и переменных не могут совпадать.
  * Структура является разновидностью типа.

  В зависимости от флагов оператора, функции оператора должны быть предоставлены указатели на [VARIABLE или] VALUE
  операндов и результата.

	Стек
  * Стек служит для упорядочения операций по приоритетам.
  * Каждая его запись стека содержит отложенную часть выражения: переменную/значение и следующую после этого операцию.
  * Запись стека должна содержать одно из трёх:
  	1. Значение.
	2. Указатель (индекс) на переменную.
	3. Признак отсутствия и значения и переменной.
  * Запись должна содержать указатель на оператор.
  ? Запись должна содержать приоритет данного оператора.
  * Требуется функция(и) для инициализации поля переменной/значения (STACKREC.Value) из символьной строки
		(возможно, с установкой типа из базовых)

	Скобки
  * Открывающая и закрывающая скобки должны соответствовать
  * Должна существовать возможность отключения выполнения выражения в скобках
  * Операндами оператора "скобки" являются выражение в скобках, перед ними и после них

  После некоторых переменных (имен) должен быть указан оператор скобки. После некоторых операторов/переменных, в скобках должны
	быть запрещены некоторые операторы

  Флаги переменных (не значений!!!)

  * Флаг требования следования определённого оператора (скобки) - OP_BROPEN
  * Поле указания типа скобки. OP_BRID
  * OP_INITB Параметр в скобках должен быть инициализирован
  * OP_LEFTB Параметр в скобках должен быть леводопустимым
  * OP_NAMEB Параметр в скобках должен иметь имя
  * OP_INITR Результат инициализирован.
  * OP_LEFTR Результат леводопустим.
  
  Функция переменной. Вызывается в случаях:

  * OP_BROPEN - при выполнении оператора скобки. Собственная функция скобки не выполняется.
  * Не OP_BROPEN - сразу после идентификации переменной в выражении.

  ++ и -- выполняются до или после ВСЕГО выражения!!! x= до ВСЕГО выражения, в порядке записи в выражении, если не смежные!!!

\**********************************************************************************************************************/

